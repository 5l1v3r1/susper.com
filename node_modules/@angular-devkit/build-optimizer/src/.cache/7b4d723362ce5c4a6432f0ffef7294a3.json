{"remainingRequest":"/home/travis/build/fossasia/susper.com/repo/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/travis/build/fossasia/susper.com/repo/node_modules/ngx-infinite-scroll/modules/ngx-infinite-scroll.es5.js","dependencies":[{"path":"/home/travis/build/fossasia/susper.com/repo/node_modules/ngx-infinite-scroll/modules/ngx-infinite-scroll.es5.js","mtime":1506422118000},{"path":"/home/travis/build/fossasia/susper.com/repo/node_modules/cache-loader/dist/cjs.js","mtime":0},{"path":"/home/travis/build/fossasia/susper.com/repo/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { Directive, ElementRef, EventEmitter, Injectable, Input, NgModule, NgZone, Output } from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/observable/fromEvent';\nimport 'rxjs/add/observable/of';\nimport 'rxjs/add/operator/sampleTime';\nimport 'rxjs/add/operator/filter';\nimport 'rxjs/add/operator/mergeMap';\nvar PositionResolver = /*@__PURE__*/ (function () {\n    function PositionResolver() {\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    PositionResolver.prototype.create = function (options) {\n        var /** @type {?} */ isWindow = this.isElementWindow(options.windowElement);\n        var /** @type {?} */ resolver = {\n            axis: options.axis,\n            container: this.defineContainer(options.windowElement, isWindow),\n            isWindow: isWindow,\n        };\n        return resolver;\n    };\n    /**\n     * @param {?} windowElement\n     * @param {?} isContainerWindow\n     * @return {?}\n     */\n    PositionResolver.prototype.defineContainer = function (windowElement, isContainerWindow) {\n        var /** @type {?} */ container = (isContainerWindow || !windowElement.nativeElement)\n            ? windowElement\n            : windowElement.nativeElement;\n        return container;\n    };\n    /**\n     * @param {?} windowElement\n     * @return {?}\n     */\n    PositionResolver.prototype.isElementWindow = function (windowElement) {\n        var /** @type {?} */ isWindow = ['Window', 'global'].some(function (obj) { return Object.prototype.toString.call(windowElement).includes(obj); });\n        return isWindow;\n    };\n    /**\n     * @param {?} isContainerWindow\n     * @param {?} windowElement\n     * @return {?}\n     */\n    PositionResolver.prototype.getDocumentElement = function (isContainerWindow, windowElement) {\n        return isContainerWindow\n            ? windowElement.document.documentElement\n            : null;\n    };\n    /**\n     * @param {?} element\n     * @param {?} resolver\n     * @return {?}\n     */\n    PositionResolver.prototype.calculatePoints = function (element, resolver) {\n        return resolver.isWindow\n            ? this.calculatePointsForWindow(element, resolver)\n            : this.calculatePointsForElement(element, resolver);\n    };\n    /**\n     * @param {?} element\n     * @param {?} resolver\n     * @return {?}\n     */\n    PositionResolver.prototype.calculatePointsForWindow = function (element, resolver) {\n        var axis = resolver.axis, container = resolver.container, isWindow = resolver.isWindow;\n        var /** @type {?} */ offsetHeightKey = axis.offsetHeightKey();\n        var /** @type {?} */ clientHeightKey = axis.clientHeightKey();\n        var /** @type {?} */ topKey = axis.topKey();\n        // container's height\n        var /** @type {?} */ height = this.height(container, isWindow, offsetHeightKey, clientHeightKey);\n        // scrolled until now / current y point\n        var /** @type {?} */ scrolledUntilNow = height + this.pageYOffset(this.getDocumentElement(isWindow, container), axis, isWindow);\n        // total height / most bottom y point\n        var /** @type {?} */ nativeElementHeight = this.height(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);\n        var /** @type {?} */ totalToScroll = this.offsetTop(element.nativeElement, axis, isWindow) + nativeElementHeight;\n        return { height: height, scrolledUntilNow: scrolledUntilNow, totalToScroll: totalToScroll };\n    };\n    /**\n     * @param {?} element\n     * @param {?} resolver\n     * @return {?}\n     */\n    PositionResolver.prototype.calculatePointsForElement = function (element, resolver) {\n        var axis = resolver.axis, container = resolver.container, isWindow = resolver.isWindow;\n        var /** @type {?} */ offsetHeightKey = axis.offsetHeightKey();\n        var /** @type {?} */ clientHeightKey = axis.clientHeightKey();\n        var /** @type {?} */ scrollTop = axis.scrollTopKey();\n        var /** @type {?} */ scrollHeight = axis.scrollHeightKey();\n        var /** @type {?} */ topKey = axis.topKey();\n        var /** @type {?} */ height = this.height(container, isWindow, offsetHeightKey, clientHeightKey);\n        // perhaps use this.container.offsetTop instead of 'scrollTop'\n        var /** @type {?} */ scrolledUntilNow = container[scrollTop];\n        var /** @type {?} */ containerTopOffset = 0;\n        var /** @type {?} */ offsetTop = this.offsetTop(container, axis, isWindow);\n        if (offsetTop !== void 0) {\n            containerTopOffset = offsetTop;\n        }\n        var /** @type {?} */ totalToScroll = container[scrollHeight];\n        return { height: height, scrolledUntilNow: scrolledUntilNow, totalToScroll: totalToScroll };\n    };\n    /**\n     * @param {?} elem\n     * @param {?} isWindow\n     * @param {?} offsetHeightKey\n     * @param {?} clientHeightKey\n     * @return {?}\n     */\n    PositionResolver.prototype.height = function (elem, isWindow, offsetHeightKey, clientHeightKey) {\n        if (isNaN(elem[offsetHeightKey])) {\n            return this.getDocumentElement(isWindow, elem)[clientHeightKey];\n        }\n        else {\n            return elem[offsetHeightKey];\n        }\n    };\n    /**\n     * @param {?} elem\n     * @param {?} axis\n     * @param {?} isWindow\n     * @return {?}\n     */\n    PositionResolver.prototype.offsetTop = function (elem, axis, isWindow) {\n        var /** @type {?} */ topKey = axis.topKey();\n        // elem = elem.nativeElement;\n        if (!elem.getBoundingClientRect) {\n            return;\n        }\n        return elem.getBoundingClientRect()[topKey] + this.pageYOffset(elem, axis, isWindow);\n    };\n    /**\n     * @param {?} elem\n     * @param {?} axis\n     * @param {?} isWindow\n     * @return {?}\n     */\n    PositionResolver.prototype.pageYOffset = function (elem, axis, isWindow) {\n        var /** @type {?} */ pageYOffset = axis.pageYOffsetKey();\n        var /** @type {?} */ scrollTop = axis.scrollTopKey();\n        var /** @type {?} */ offsetTop = axis.offsetTopKey();\n        if (isNaN(window[pageYOffset])) {\n            return this.getDocumentElement(isWindow, elem)[scrollTop];\n        }\n        else if (elem.ownerDocument) {\n            return elem.ownerDocument.defaultView[pageYOffset];\n        }\n        else {\n            return elem[offsetTop];\n        }\n    };\n    return PositionResolver;\n}());\nvar ScrollRegister = /*@__PURE__*/ (function () {\n    function ScrollRegister() {\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    ScrollRegister.prototype.attachEvent = function (options) {\n        var /** @type {?} */ scroller$ = Observable.fromEvent(options.container, 'scroll')\n            .sampleTime(options.throttleDuration)\n            .filter(options.filterBefore)\n            .mergeMap(function (ev) { return Observable.of(options.mergeMap(ev)); })\n            .subscribe(options.scrollHandler);\n        return scroller$;\n    };\n    return ScrollRegister;\n}());\nvar ScrollResolver = /*@__PURE__*/ (function () {\n    function ScrollResolver() {\n        this.lastScrollPosition = 0;\n    }\n    /**\n     * @param {?} container\n     * @param {?} config\n     * @param {?} scrollingDown\n     * @return {?}\n     */\n    ScrollResolver.prototype.shouldScroll = function (container, config, scrollingDown) {\n        var /** @type {?} */ distance = config.distance;\n        var /** @type {?} */ remaining;\n        var /** @type {?} */ containerBreakpoint;\n        if (scrollingDown) {\n            remaining = container.totalToScroll - container.scrolledUntilNow;\n            containerBreakpoint = container.height * distance.down + 1;\n        }\n        else {\n            remaining = container.scrolledUntilNow;\n            containerBreakpoint = container.height * distance.up + 1;\n        }\n        var /** @type {?} */ shouldScroll = remaining <= containerBreakpoint;\n        this.lastScrollPosition = container.scrolledUntilNow;\n        return shouldScroll;\n    };\n    /**\n     * @param {?} container\n     * @return {?}\n     */\n    ScrollResolver.prototype.isScrollingDown = function (container) {\n        return this.lastScrollPosition < container.scrolledUntilNow;\n    };\n    /**\n     * @param {?} container\n     * @param {?} config\n     * @return {?}\n     */\n    ScrollResolver.prototype.getScrollStats = function (container, config) {\n        var /** @type {?} */ isScrollingDown = this.isScrollingDown(container);\n        var /** @type {?} */ shouldScroll = this.shouldScroll(container, config, isScrollingDown);\n        return { isScrollingDown: isScrollingDown, shouldScroll: shouldScroll };\n    };\n    return ScrollResolver;\n}());\nvar AxisResolver = /*@__PURE__*/ (function () {\n    /**\n     * @param {?=} vertical\n     */\n    function AxisResolver(vertical) {\n        if (vertical === void 0) {\n            vertical = true;\n        }\n        this.vertical = vertical;\n    }\n    /**\n     * @return {?}\n     */\n    AxisResolver.prototype.clientHeightKey = function () { return this.vertical ? 'clientHeight' : 'clientWidth'; };\n    /**\n     * @return {?}\n     */\n    AxisResolver.prototype.offsetHeightKey = function () { return this.vertical ? 'offsetHeight' : 'offsetWidth'; };\n    /**\n     * @return {?}\n     */\n    AxisResolver.prototype.scrollHeightKey = function () { return this.vertical ? 'scrollHeight' : 'scrollWidth'; };\n    /**\n     * @return {?}\n     */\n    AxisResolver.prototype.pageYOffsetKey = function () { return this.vertical ? 'pageYOffset' : 'pageXOffset'; };\n    /**\n     * @return {?}\n     */\n    AxisResolver.prototype.offsetTopKey = function () { return this.vertical ? 'offsetTop' : 'offsetLeft'; };\n    /**\n     * @return {?}\n     */\n    AxisResolver.prototype.scrollTopKey = function () { return this.vertical ? 'scrollTop' : 'scrollLeft'; };\n    /**\n     * @return {?}\n     */\n    AxisResolver.prototype.topKey = function () { return this.vertical ? 'top' : 'left'; };\n    return AxisResolver;\n}());\n/**\n * @param {?} selector\n * @param {?} scrollWindow\n * @param {?} defaultElement\n * @return {?}\n */\nfunction resolveContainerElement(selector, scrollWindow, defaultElement) {\n    var /** @type {?} */ hasWindow = window && window.hasOwnProperty('document');\n    var /** @type {?} */ containerIsString = selector && hasWindow && typeof (selector) === 'string';\n    var /** @type {?} */ container = containerIsString\n        ? window.document.querySelector(selector)\n        : selector;\n    if (!selector) {\n        container = scrollWindow ? window : defaultElement;\n    }\n    return container;\n}\nvar InfiniteScrollDirective = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} element\n     * @param {?} zone\n     * @param {?} positionResolver\n     * @param {?} scrollRegister\n     * @param {?} scrollerResolver\n     */\n    function InfiniteScrollDirective(element, zone, positionResolver, scrollRegister, scrollerResolver) {\n        this.element = element;\n        this.zone = zone;\n        this.positionResolver = positionResolver;\n        this.scrollRegister = scrollRegister;\n        this.scrollerResolver = scrollerResolver;\n        this.scrolled = new EventEmitter();\n        this.scrolledUp = new EventEmitter();\n        this.infiniteScrollDistance = 2;\n        this.infiniteScrollUpDistance = 1.5;\n        this.infiniteScrollThrottle = 300;\n        this.infiniteScrollDisabled = false;\n        this.infiniteScrollContainer = null;\n        this.scrollWindow = true;\n        this.immediateCheck = false;\n        this.horizontal = false;\n        this.alwaysCallback = false;\n    }\n    /**\n     * @return {?}\n     */\n    InfiniteScrollDirective.prototype.ngOnInit = function () {\n        this.setup();\n    };\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    InfiniteScrollDirective.prototype.ngOnChanges = function (_a) {\n        var infiniteScrollContainer = _a.infiniteScrollContainer;\n        var /** @type {?} */ scrollContainerChanged = infiniteScrollContainer && !infiniteScrollContainer.firstChange;\n        if (scrollContainerChanged) {\n            this.destroyScroller();\n            this.setup();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    InfiniteScrollDirective.prototype.setup = function () {\n        var _this = this;\n        if (typeof window !== 'undefined') {\n            this.zone.runOutsideAngular(function () {\n                var /** @type {?} */ containerElement = resolveContainerElement(_this.infiniteScrollContainer, _this.scrollWindow, _this.element);\n                var /** @type {?} */ resolver = _this.positionResolver.create({\n                    axis: new AxisResolver(!_this.horizontal),\n                    windowElement: containerElement,\n                });\n                var /** @type {?} */ options = {\n                    container: resolver.container,\n                    filterBefore: function () { return !_this.infiniteScrollDisabled; },\n                    mergeMap: function () { return _this.positionResolver.calculatePoints(_this.element, resolver); },\n                    scrollHandler: function (container) { return _this.handleOnScroll(container); },\n                    throttleDuration: _this.infiniteScrollThrottle\n                };\n                _this.disposeScroller = _this.scrollRegister.attachEvent(options);\n            });\n        }\n    };\n    /**\n     * @param {?} container\n     * @return {?}\n     */\n    InfiniteScrollDirective.prototype.handleOnScroll = function (container) {\n        var /** @type {?} */ distance = {\n            down: this.infiniteScrollDistance,\n            up: this.infiniteScrollUpDistance\n        };\n        var /** @type {?} */ scrollStats = this.scrollerResolver.getScrollStats(container, { distance: distance });\n        if (this.shouldTriggerEvents(scrollStats.shouldScroll)) {\n            var /** @type {?} */ infiniteScrollEvent = {\n                currentScrollPosition: container.scrolledUntilNow\n            };\n            if (scrollStats.isScrollingDown) {\n                this.onScrollDown(infiniteScrollEvent);\n            }\n            else {\n                this.onScrollUp(infiniteScrollEvent);\n            }\n        }\n    };\n    /**\n     * @param {?} shouldScroll\n     * @return {?}\n     */\n    InfiniteScrollDirective.prototype.shouldTriggerEvents = function (shouldScroll) {\n        return (this.alwaysCallback || shouldScroll) && !this.infiniteScrollDisabled;\n    };\n    /**\n     * @return {?}\n     */\n    InfiniteScrollDirective.prototype.ngOnDestroy = function () {\n        this.destroyScroller();\n    };\n    /**\n     * @param {?=} data\n     * @return {?}\n     */\n    InfiniteScrollDirective.prototype.onScrollDown = function (data) {\n        var _this = this;\n        if (data === void 0) {\n            data = { currentScrollPosition: 0 };\n        }\n        this.zone.run(function () { return _this.scrolled.emit(data); });\n    };\n    /**\n     * @param {?=} data\n     * @return {?}\n     */\n    InfiniteScrollDirective.prototype.onScrollUp = function (data) {\n        var _this = this;\n        if (data === void 0) {\n            data = { currentScrollPosition: 0 };\n        }\n        this.zone.run(function () { return _this.scrolledUp.emit(data); });\n    };\n    /**\n     * @return {?}\n     */\n    InfiniteScrollDirective.prototype.destroyScroller = function () {\n        if (this.disposeScroller) {\n            this.disposeScroller.unsubscribe();\n        }\n    };\n    return InfiniteScrollDirective;\n}());\nvar InfiniteScrollModule = /*@__PURE__*/ (function () {\n    function InfiniteScrollModule() {\n    }\n    return InfiniteScrollModule;\n}());\n/**\n * Angular library starter.\n * Build an Angular library compatible with AoT compilation & Tree shaking.\n * Written by Roberto Simonetti.\n * MIT license.\n * https://github.com/robisim74/angular-library-starter\n */\n/**\n * Entry point for all public APIs of the package.\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { InfiniteScrollDirective, PositionResolver, AxisResolver, ScrollRegister, ScrollResolver, InfiniteScrollModule };\n//# sourceMappingURL=ngx-infinite-scroll.es5.js.map\n",null]}